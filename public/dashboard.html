<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Erwin Dashboard</title>
    <link rel="stylesheet" href="/assets/styles.css" />
  </head>
  <body>
    <header>
      <h1>Erwin Dashboard</h1>
      <p>Manage playlists, control playback, and monitor vote rounds.</p>
      <nav class="tabs" aria-label="Dashboard tabs">
        <a class="tab-link active" href="#" data-tab="player">Music Player Dashboard</a>
        <a class="tab-link" href="#" data-tab="playlists">Playlist Editor</a>
        <a class="tab-link" href="#" data-tab="chat">Live Chat Feed</a>
        <a class="tab-link" href="#" data-tab="settings">Settings</a>
      </nav>
    </header>

    <main>
      <section class="tab-panel active" data-tab-panel="player">
        <div class="grid two">
          <div class="card">
            <div class="card-header">
              <h2>Music Player Dashboard</h2>
              <button id="open-stream" class="secondary">Open Stream Player</button>
            </div>
            <div class="section-title">Now Playing</div>
            <div id="now-playing" class="list-item">No track loaded yet.</div>
            <div class="section-title" style="margin-top: 16px;">Queue</div>
            <div id="queue" class="list">
              <div class="list-item">Queue is empty.</div>
            </div>
            <div class="section-title" style="margin-top: 16px;">Pool</div>
            <div id="pool" class="list">
              <div class="list-item">Pool is empty.</div>
            </div>
          </div>

          <div class="card">
            <div class="card-header">
              <h2>Voting</h2>
              <div class="card-header-actions">
                <label class="card-toggle" for="auto-vote-toggle">
                  <input id="auto-vote-toggle" type="checkbox" />
                  Auto vote
                </label>
                <button id="start-vote" class="secondary">Start Vote</button>
              </div>
            </div>
            <div class="list">
              <div class="list-item">
                <span>Vote status</span>
                <span class="badge" id="vote-status">Idle</span>
              </div>
              <div class="list-item">
                <span>Vote window</span>
                <span id="vote-window">--</span>
              </div>
            </div>
            <div class="section-title" style="margin-top: 16px;">Vote options</div>
            <div id="vote-options" class="list">
              <div class="list-item">No active vote.</div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-tab-panel="playlists">
        <div class="grid two">
          <div class="card">
            <h2>Playlist Editor</h2>
            <div class="section-title">Create Playlist</div>
            <form id="playlist-form" class="grid">
              <div>
                <label for="playlist-name">Playlist name</label>
                <input id="playlist-name" name="playlist-name" required />
              </div>
              <button type="submit">Create Playlist</button>
            </form>

            <div class="section-title" style="margin-top: 16px;">Playlists</div>
            <div id="playlists" class="list">
              <div class="list-item">No playlists yet.</div>
            </div>
          </div>

          <div class="card">
            <h2>Track Management</h2>
            <form id="track-form" class="grid">
              <div>
                <label for="track-playlist">Playlist</label>
                <select id="track-playlist" name="track-playlist"></select>
              </div>
              <div>
                <label for="track-url">YouTube Track or Playlist URL</label>
                <input id="track-url" name="track-url" placeholder="https://youtu.be/... or https://www.youtube.com/playlist?list=..." />
              </div>
              <button type="submit">Add</button>
            </form>
            <div class="section-title" style="margin-top: 16px; display: flex; align-items: center; justify-content: space-between;">
              <span>Download Queue</span>
              <button id="clear-downloads" class="secondary" type="button">Clear Completed</button>
            </div>
            <div id="download-queue" class="list">
              <div class="list-item">No downloads yet.</div>
            </div>
          </div>

          <div class="card">
            <div class="track-editor-header">
              <div>
                <h2>Track Editor</h2>
              </div>
              <div class="track-editor-tools">
                <label for="track-filter">Filter</label>
                <input id="track-filter" type="search" placeholder="Search tracks..." />
                <div id="track-count" class="notice">0 tracks</div>
              </div>
            </div>
            <div id="tracks" class="list track-list">
              <div class="list-item">Select a playlist to view tracks.</div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-tab-panel="chat">
        <div class="grid two">
          <div class="card">
            <h2>Live Chat Feed</h2>
            <p class="notice">Incoming Twitch chat messages and bot actions appear here in real time.</p>
            <div id="chat-feed" class="list chat-feed">
              <div class="list-item">
                <span class="badge">System</span>
                <span>Waiting for chat activity...</span>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="tab-panel" data-tab-panel="settings">
        <div class="grid two">
          <div class="card">
            <h2>Settings</h2>
            <form id="settings-form" class="grid">
              <div>
                <label for="settings-vote-options">Vote options</label>
                <input id="settings-vote-options" name="vote-options" type="number" min="2" max="10" />
              </div>
              <div>
                <label for="settings-vote-duration">Vote duration (seconds)</label>
                <input id="settings-vote-duration" name="vote-duration" type="number" min="5" step="1" />
              </div>
              <div>
                <label for="settings-vote-lead">Vote lead time (seconds)</label>
                <input id="settings-vote-lead" name="vote-lead" type="number" min="0" step="1" />
              </div>
              <div class="section-title form-section-title">Twitch Chat Messages</div>
              <p class="notice form-section-title">
                Templates support {command}, {summary}, {number}, {title}, {channel}, {track},
                {winner}, and {max}.
              </p>
              <div>
                <label for="settings-twitch-welcome">Welcome message</label>
                <textarea id="settings-twitch-welcome" name="twitch-welcome" rows="2"></textarea>
              </div>
              <div>
                <label for="settings-twitch-vote-start">Vote start message</label>
                <input id="settings-twitch-vote-start" name="twitch-vote-start" />
              </div>
              <div>
                <label for="settings-twitch-vote-option">Vote option line</label>
                <input id="settings-twitch-vote-option" name="twitch-vote-option" />
              </div>
              <div>
                <label for="settings-twitch-vote-end">Vote end message</label>
                <input id="settings-twitch-vote-end" name="twitch-vote-end" />
              </div>
              <div>
                <label for="settings-twitch-now-playing">Now playing message</label>
                <input id="settings-twitch-now-playing" name="twitch-now-playing" />
              </div>
              <div>
                <label for="settings-twitch-no-active">No active vote message</label>
                <input id="settings-twitch-no-active" name="twitch-no-active" />
              </div>
              <div>
                <label for="settings-twitch-vote-closed">Vote closed message</label>
                <input id="settings-twitch-vote-closed" name="twitch-vote-closed" />
              </div>
              <div>
                <label for="settings-twitch-invalid-vote">Invalid vote message</label>
                <input id="settings-twitch-invalid-vote" name="twitch-invalid-vote" />
              </div>
              <div>
                <label for="settings-twitch-skip">Skip message</label>
                <input id="settings-twitch-skip" name="twitch-skip" />
              </div>
              <div>
                <label for="settings-twitch-pause">Pause message</label>
                <input id="settings-twitch-pause" name="twitch-pause" />
              </div>
              <div>
                <label for="settings-twitch-resume">Resume message</label>
                <input id="settings-twitch-resume" name="twitch-resume" />
              </div>
              <button type="submit">Save Settings</button>
            </form>
            <p id="settings-status" class="notice" aria-live="polite"></p>
          </div>
        </div>
      </section>
    </main>

    <footer class="footer">
      <span class="status-pill"><span></span> Connected</span>
      <button id="logout" class="secondary" style="float: right;">Logout</button>
    </footer>

    <div id="rename-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="rename-title">
      <div class="modal-card">
        <h3 id="rename-title">Rename Track</h3>
        <p class="notice">Update the display title for this track.</p>
        <label for="rename-input">New title</label>
        <input id="rename-input" type="text" placeholder="Track title" />
        <div class="modal-actions">
          <button id="rename-cancel" class="secondary" type="button">Cancel</button>
          <button id="rename-save" type="button">Save</button>
        </div>
      </div>
    </div>

    <script>
      const nowPlaying = document.getElementById("now-playing");
      const queueEl = document.getElementById("queue");
      const poolEl = document.getElementById("pool");
      const playlistsEl = document.getElementById("playlists");
      const tracksEl = document.getElementById("tracks");
      const downloadQueueEl = document.getElementById("download-queue");
      const trackPlaylist = document.getElementById("track-playlist");
      const playlistForm = document.getElementById("playlist-form");
      const trackForm = document.getElementById("track-form");
      const trackFilter = document.getElementById("track-filter");
      const trackCount = document.getElementById("track-count");
      const renameModal = document.getElementById("rename-modal");
      const renameInput = document.getElementById("rename-input");
      const renameSave = document.getElementById("rename-save");
      const renameCancel = document.getElementById("rename-cancel");
      const voteStatus = document.getElementById("vote-status");
      const voteWindow = document.getElementById("vote-window");
      const voteOptionsEl = document.getElementById("vote-options");
      const startVoteButton = document.getElementById("start-vote");
      const chatFeed = document.getElementById("chat-feed");
      const settingsForm = document.getElementById("settings-form");
      const settingsStatus = document.getElementById("settings-status");
      const settingsVoteOptions = document.getElementById("settings-vote-options");
      const settingsVoteDuration = document.getElementById("settings-vote-duration");
      const settingsVoteLead = document.getElementById("settings-vote-lead");
      const autoVoteToggle = document.getElementById("auto-vote-toggle");
      const settingsTwitchWelcome = document.getElementById("settings-twitch-welcome");
      const settingsTwitchVoteStart = document.getElementById("settings-twitch-vote-start");
      const settingsTwitchVoteOption = document.getElementById("settings-twitch-vote-option");
      const settingsTwitchVoteEnd = document.getElementById("settings-twitch-vote-end");
      const settingsTwitchNowPlaying = document.getElementById("settings-twitch-now-playing");
      const settingsTwitchNoActive = document.getElementById("settings-twitch-no-active");
      const settingsTwitchVoteClosed = document.getElementById("settings-twitch-vote-closed");
      const settingsTwitchInvalidVote = document.getElementById("settings-twitch-invalid-vote");
      const settingsTwitchSkip = document.getElementById("settings-twitch-skip");
      const settingsTwitchPause = document.getElementById("settings-twitch-pause");
      const settingsTwitchResume = document.getElementById("settings-twitch-resume");
      let playlistsCache = [];
      let selectedPlaylistId = null;
      let renameTrackId = null;
      let activeVote = null;
      let voteTimer = null;
      let poolTrackIds = new Set();
      const chatMessages = [];
      const DEFAULT_TWITCH_MESSAGES = {
        vote_start: "Vote time! Choose the next track with {command}vote <number>.",
        vote_option: "{number}. {title}{channel}",
        vote_end: "Vote ended! Winner: {winner}",
        now_playing: "Now playing: {track}",
        no_active: "No active vote right now.",
        vote_closed: "Voting is closed.",
        invalid_vote: "Invalid vote. Choose 1-{max}.",
        skip: "Skipped to the next track.",
        pause: "Playback paused.",
        resume: "Playback resumed."
      };

      document.querySelectorAll(".tab-link").forEach((link) => {
        link.addEventListener("click", (event) => {
          event.preventDefault();
          const target = link.dataset.tab;
          document.querySelectorAll(".tab-link").forEach((tab) => {
            tab.classList.toggle("active", tab.dataset.tab === target);
          });
          document.querySelectorAll(".tab-panel").forEach((panel) => {
            panel.classList.toggle("active", panel.dataset.tabPanel === target);
          });
        });
      });

      function renderTracks() {
        if (!selectedPlaylistId) {
          tracksEl.innerHTML = '<div class="list-item">Select a playlist to view tracks.</div>';
          trackCount.textContent = "0 tracks";
          return;
        }
        const playlist = playlistsCache.find((item) => item.id === selectedPlaylistId);
        if (!playlist || playlist.tracks.length === 0) {
          tracksEl.innerHTML = '<div class="list-item">No tracks in this playlist yet.</div>';
          trackCount.textContent = "0 tracks";
          return;
        }
        const query = trackFilter.value.trim().toLowerCase();
        const positions = new Map(playlist.tracks.map((track, index) => [track.id, index]));
        const filtered = playlist.tracks.filter((track) => {
          if (!query) return true;
          return (
            track.title?.toLowerCase().includes(query) ||
            track.youtube_id?.toLowerCase().includes(query) ||
            track.url?.toLowerCase().includes(query)
          );
        });
        trackCount.textContent = `${filtered.length} / ${playlist.tracks.length} tracks`;
        tracksEl.innerHTML = filtered
          .map((track, index) => {
            const label = track.title || "Untitled track";
            const trackIndex = positions.get(track.id) ?? index;
            const disabled = Boolean(track.disabled);
            const disabledLabel = disabled ? '<span class="badge">Disabled</span>' : "";
            const toggleLabel = disabled ? "Enable track" : "Disable track";
            const toggleIcon = disabled ? "‚úÖ" : "üö´";
            const inPool = poolTrackIds.has(track.id);
            const poolDisabled = inPool ? "disabled" : "";
            const poolLabel = inPool ? "In pool" : "Add to pool";
            return `<div class="list-item ${disabled ? "disabled" : ""}" data-track-id="${track.id}" data-track-title="${track.title || ""}" data-track-disabled="${disabled}">
                <div style="flex: 1;">
                  <div style="display: flex; gap: 8px; align-items: center;">${label} ${disabledLabel}</div>
                </div>
                <div class="actions">
                  <button class="secondary" data-action="enqueue" title="Add to queue end" aria-label="Add to queue end">Queue end</button>
                  <button class="secondary" data-action="pool-add" ${poolDisabled} title="${poolLabel}" aria-label="${poolLabel}">${poolLabel}</button>
                  <button class="secondary icon-only" data-action="rename" title="Rename track" aria-label="Rename track">‚úèÔ∏è</button>
                  <button class="secondary icon-only" data-action="toggle-disabled" title="${toggleLabel}" aria-label="${toggleLabel}">${toggleIcon}</button>
                  <button class="secondary icon-only" data-action="up" ${trackIndex === 0 ? "disabled" : ""} title="Move up" aria-label="Move up">‚¨ÜÔ∏è</button>
                  <button class="secondary icon-only" data-action="down" ${trackIndex === playlist.tracks.length - 1 ? "disabled" : ""} title="Move down" aria-label="Move down">‚¨áÔ∏è</button>
                  <button class="ghost icon-only" data-action="remove" title="Remove track" aria-label="Remove track">üóëÔ∏è</button>
                </div>
              </div>`;
          })
          .join("");
      }

      function formatRemainingTime(endsAt) {
        if (!endsAt) return "--";
        const remainingMs = new Date(endsAt).getTime() - Date.now();
        if (remainingMs <= 0) return "0s";
        const seconds = Math.ceil(remainingMs / 1000);
        return `${seconds}s`;
      }

      function renderVoteOptions() {
        if (!activeVote || !activeVote.options?.length) {
          voteOptionsEl.innerHTML = '<div class="list-item">No active vote.</div>';
          voteStatus.textContent = "Idle";
          voteWindow.textContent = "--";
          return;
        }
        const counts = activeVote.counts || {};
        voteStatus.textContent = activeVote.status || "Active";
        voteWindow.textContent =
          activeVote.status === "Ended"
            ? "Completed"
            : formatRemainingTime(activeVote.endsAt);
        const winnerMarkup = activeVote.winner
          ? `<div class="list-item"><span>Winner</span><span class="badge">${activeVote.winner.title || activeVote.winner.trackId}</span></div>`
          : "";
        voteOptionsEl.innerHTML = activeVote.options
          .map((option, index) => {
            const count = counts[index + 1] || 0;
            const title = option.title || option.trackId;
            return `<div class="list-item">
                <span>${index + 1}. ${title}</span>
                <span class="badge">${count} votes</span>
              </div>`;
          })
          .join("");
        if (winnerMarkup) {
          voteOptionsEl.innerHTML = `${winnerMarkup}${voteOptionsEl.innerHTML}`;
        }
      }

      function startVoteTimer() {
        if (voteTimer) {
          clearInterval(voteTimer);
        }
        voteTimer = setInterval(() => {
          if (!activeVote) {
            clearInterval(voteTimer);
            voteTimer = null;
            return;
          }
          renderVoteOptions();
        }, 1000);
      }

      function setActiveVote(payload) {
        if (!payload) {
          activeVote = null;
          renderVoteOptions();
          return;
        }
        activeVote = {
          roundId: payload.roundId,
          startedAt: payload.startedAt,
          endsAt: payload.endsAt,
          options: payload.options || [],
          counts: payload.counts || {},
          status: payload.status || "Active",
          winner: payload.winner || null
        };
        renderVoteOptions();
        startVoteTimer();
      }

      function appendChatMessage(entry) {
        if (!entry) return;
        const normalized = {
          role: entry.role || "viewer",
          user: entry.user || "Unknown",
          ...entry
        };
        chatMessages.push(normalized);
        if (chatMessages.length > 200) {
          chatMessages.shift();
        }
        chatFeed.innerHTML = chatMessages
          .slice(-100)
          .map((message) => {
            const badgeLabel = message.isSystem
              ? "System"
              : message.role === "mod"
                ? "Mod"
                : "Viewer";
            const commandFlag = message.isCommand ? '<span class="badge">Command</span>' : "";
            return `<div class="list-item">
                <span class="badge">${badgeLabel}</span>
                <span><strong>${message.user}</strong>: ${message.message}</span>
                ${commandFlag}
              </div>`;
          })
          .join("");
      }

      async function fetchState() {
        const response = await fetch("/api/state");
        if (!response.ok) return;
        const { playState, queue, currentTrack } = await response.json();
        if (playState?.current_track_id && currentTrack) {
          const title = currentTrack.title || "Untitled track";
          nowPlaying.textContent = playState.paused
            ? `Paused: ${title}`
            : `Now Playing: ${title}`;
        } else if (playState?.paused) {
          nowPlaying.textContent = "Playback paused.";
        } else {
          nowPlaying.textContent = "Nothing is playing.";
        }
        if (!queue || queue.length === 0) {
          queueEl.innerHTML = '<div class="list-item">Queue is empty.</div>';
        } else {
          queueEl.innerHTML = queue
            .map(
              (item, index) =>
                `<div class="list-item" data-queue-id="${item.id}">
                  <span>${item.title || item.track_id}</span>
                  <div class="actions">
                    <span class="badge">${item.source}</span>
                    <button class="secondary icon-only" data-action="queue-up" ${index === 0 ? "disabled" : ""} title="Move up" aria-label="Move up">‚¨ÜÔ∏è</button>
                    <button class="secondary icon-only" data-action="queue-down" ${index === queue.length - 1 ? "disabled" : ""} title="Move down" aria-label="Move down">‚¨áÔ∏è</button>
                  </div>
                </div>`
            )
            .join("");
        }
      }

      async function fetchPool() {
        const response = await fetch("/api/pool");
        if (!response.ok) return;
        const pool = await response.json();
        poolTrackIds = new Set(pool.map((item) => item.track_id));
        if (!pool.length) {
          poolEl.innerHTML = '<div class="list-item">Pool is empty.</div>';
          renderTracks();
          return;
        }
        poolEl.innerHTML = pool
          .map(
            (item) =>
              `<div class="list-item" data-track-id="${item.track_id}">
                <span>${item.title || item.track_id}</span>
                <div class="actions">
                  <button class="secondary icon-only" data-action="pool-enqueue" title="Enqueue track" aria-label="Enqueue track">‚ûï</button>
                </div>
              </div>`
          )
          .join("");
        renderTracks();
      }

      async function fetchPlaylists() {
        const response = await fetch("/api/playlists");
        if (!response.ok) return;
        playlistsCache = await response.json();
        playlistsEl.innerHTML = "";
        trackPlaylist.innerHTML = "";
        if (playlistsCache.length === 0) {
          playlistsEl.innerHTML = '<div class="list-item">No playlists yet.</div>';
          selectedPlaylistId = null;
          renderTracks();
          return;
        }
        for (const playlist of playlistsCache) {
          const item = document.createElement("div");
          item.className = "list-item";
          item.innerHTML = `
            <div>
              <button class="inline secondary" data-action="select" data-playlist-id="${playlist.id}">
                ${playlist.name}
              </button>
              <span class="badge">${playlist.tracks.length} tracks</span>
            </div>
            <div class="actions">
              <button class="ghost" data-action="play" data-playlist-id="${playlist.id}">Play</button>
              <button class="ghost" data-action="delete" data-playlist-id="${playlist.id}" data-playlist-name="${playlist.name}">Delete</button>
            </div>
          `;
          playlistsEl.appendChild(item);

          const trackOption = document.createElement("option");
          trackOption.value = playlist.id;
          trackOption.textContent = playlist.name;
          trackPlaylist.appendChild(trackOption);
        }
        const selectedExists = selectedPlaylistId
          ? playlistsCache.some((playlist) => playlist.id === selectedPlaylistId)
          : false;
        if (!selectedExists && playlistsCache.length > 0) {
          selectedPlaylistId = playlistsCache[0].id;
        }
        if (selectedPlaylistId) {
          trackPlaylist.value = selectedPlaylistId;
        }
        renderTracks();
      }

      async function fetchSettings() {
        const response = await fetch("/api/settings");
        if (!response.ok) return;
        const settings = await response.json();
        settingsVoteOptions.value = settings.vote_options ?? settings.voteOptions ?? 5;
        settingsVoteDuration.value = settings.vote_duration ?? settings.voteDuration ?? 30;
        settingsVoteLead.value = settings.vote_lead_time ?? settings.voteLeadTime ?? 20;
        const autoVoteSetting = settings.vote_auto_enabled ?? settings.voteAutoEnabled ?? 1;
        autoVoteToggle.checked = String(autoVoteSetting) !== "0";
        settingsTwitchWelcome.value = settings.twitch_welcome_message ?? settings.twitchWelcomeMessage ?? "";
        settingsTwitchVoteStart.value =
          settings.twitch_vote_start_message ?? settings.twitchVoteStartMessage ?? DEFAULT_TWITCH_MESSAGES.vote_start;
        settingsTwitchVoteOption.value =
          settings.twitch_vote_option_message ?? settings.twitchVoteOptionMessage ?? DEFAULT_TWITCH_MESSAGES.vote_option;
        settingsTwitchVoteEnd.value =
          settings.twitch_vote_end_message ?? settings.twitchVoteEndMessage ?? DEFAULT_TWITCH_MESSAGES.vote_end;
        settingsTwitchNowPlaying.value =
          settings.twitch_now_playing_message ?? settings.twitchNowPlayingMessage ?? DEFAULT_TWITCH_MESSAGES.now_playing;
        settingsTwitchNoActive.value =
          settings.twitch_no_active_vote_message ?? settings.twitchNoActiveVoteMessage ?? DEFAULT_TWITCH_MESSAGES.no_active;
        settingsTwitchVoteClosed.value =
          settings.twitch_vote_closed_message ?? settings.twitchVoteClosedMessage ?? DEFAULT_TWITCH_MESSAGES.vote_closed;
        settingsTwitchInvalidVote.value =
          settings.twitch_invalid_vote_message ?? settings.twitchInvalidVoteMessage ?? DEFAULT_TWITCH_MESSAGES.invalid_vote;
        settingsTwitchSkip.value =
          settings.twitch_skip_message ?? settings.twitchSkipMessage ?? DEFAULT_TWITCH_MESSAGES.skip;
        settingsTwitchPause.value =
          settings.twitch_pause_message ?? settings.twitchPauseMessage ?? DEFAULT_TWITCH_MESSAGES.pause;
        settingsTwitchResume.value =
          settings.twitch_resume_message ?? settings.twitchResumeMessage ?? DEFAULT_TWITCH_MESSAGES.resume;
      }

      async function fetchActiveVote() {
        const response = await fetch("/api/votes/active");
        if (!response.ok) return;
        const data = await response.json();
        if (!data.active) {
          setActiveVote(null);
          return;
        }
        setActiveVote(data.round);
      }

      async function fetchDownloads() {
        const response = await fetch("/api/downloads");
        if (!response.ok) return;
        const downloads = await response.json();
        if (!downloads.length) {
          downloadQueueEl.innerHTML = '<div class="list-item">No downloads yet.</div>';
          return;
        }
        downloadQueueEl.innerHTML = downloads
          .map((item) => {
            const label = item.title || item.youtube_id;
            const status = item.status;
            const details = item.error ? ` - ${item.error}` : "";
            return `<div class="list-item"><span>${label} (${item.playlist_name})${details}</span><span class="badge">${status}</span></div>`;
          })
          .join("");
      }

      playlistsEl.addEventListener("click", async (event) => {
        const button = event.target.closest("button");
        if (!button) return;
        const action = button.dataset.action;
        const playlistId = button.dataset.playlistId;
        if (!playlistId) return;
        if (action === "select") {
          selectedPlaylistId = playlistId;
          trackPlaylist.value = playlistId;
          renderTracks();
        }
        if (action === "play") {
          await fetch(`/api/playlists/${playlistId}/play`, { method: "POST" });
          fetchState();
        }
        if (action === "delete") {
          const name = button.dataset.playlistName || "this playlist";
          if (window.confirm(`Delete ${name}? This cannot be undone.`)) {
            await fetch(`/api/playlists/${playlistId}`, { method: "DELETE" });
            if (selectedPlaylistId === playlistId) {
              selectedPlaylistId = null;
            }
            fetchPlaylists();
          }
        }
      });

      trackPlaylist.addEventListener("change", () => {
        selectedPlaylistId = trackPlaylist.value || null;
        renderTracks();
      });

      trackFilter.addEventListener("input", () => {
        renderTracks();
      });

      tracksEl.addEventListener("click", async (event) => {
        const button = event.target.closest("button");
        if (!button) return;
        const action = button.dataset.action;
        const wrapper = button.closest(".list-item");
        const trackId = wrapper?.dataset.trackId;
        const isDisabled = wrapper?.dataset.trackDisabled === "true";
        if (!trackId || !selectedPlaylistId) return;
        if (action === "enqueue") {
          await fetch("/api/queue/enqueue", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ trackId, source: "dashboard" })
          });
        }
        if (action === "remove") {
          await fetch(`/api/playlists/${selectedPlaylistId}/tracks/${trackId}`, { method: "DELETE" });
        }
        if (action === "pool-add") {
          await fetch("/api/pool/add", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ trackId })
          });
        }
        if (action === "rename") {
          renameTrackId = trackId;
          renameInput.value = wrapper.dataset.trackTitle || "";
          renameModal.classList.remove("hidden");
          renameInput.focus();
        }
        if (action === "up" || action === "down") {
          await fetch(`/api/playlists/${selectedPlaylistId}/tracks/${trackId}/move`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ direction: action })
          });
        }
        if (action === "toggle-disabled") {
          await fetch(`/api/tracks/${trackId}/disable`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ disabled: !isDisabled })
          });
        }
        fetchPlaylists();
      });

      queueEl.addEventListener("click", async (event) => {
        const button = event.target.closest("button");
        if (!button) return;
        const action = button.dataset.action;
        const wrapper = button.closest(".list-item");
        const queueId = wrapper?.dataset.queueId;
        if (!queueId) return;
        if (action === "queue-up" || action === "queue-down") {
          await fetch(`/api/queue/${queueId}/move`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ direction: action === "queue-up" ? "up" : "down" })
          });
          fetchState();
        }
      });

      poolEl.addEventListener("click", async (event) => {
        const button = event.target.closest("button");
        if (!button) return;
        const action = button.dataset.action;
        const wrapper = button.closest(".list-item");
        const trackId = wrapper?.dataset.trackId;
        if (action !== "pool-enqueue" || !trackId) return;
        await fetch("/api/pool/enqueue", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ trackId })
        });
        fetchPool();
        fetchState();
      });

      function closeRenameModal() {
        renameModal.classList.add("hidden");
        renameTrackId = null;
        renameInput.value = "";
      }

      renameCancel.addEventListener("click", () => {
        closeRenameModal();
      });

      renameModal.addEventListener("click", (event) => {
        if (event.target === renameModal) {
          closeRenameModal();
        }
      });

      renameSave.addEventListener("click", async () => {
        const title = renameInput.value.trim();
        if (!renameTrackId || !title) return;
        await fetch(`/api/tracks/${renameTrackId}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ title })
        });
        closeRenameModal();
        fetchPlaylists();
      });

      document.getElementById("open-stream").addEventListener("click", () => {
        window.open("/player/stream", "erwin-stream", "width=1100,height=720");
      });

      startVoteButton.addEventListener("click", async () => {
        await fetch("/api/votes/start", { method: "POST" });
        fetchActiveVote();
      });

      playlistForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const name = playlistForm["playlist-name"].value;
        await fetch("/api/playlists", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name })
        });
        playlistForm.reset();
        fetchPlaylists();
      });

      trackForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        const playlistId = trackForm["track-playlist"].value;
        const url = trackForm["track-url"].value;
        if (!playlistId || !url) return;
        if (url.includes("list=")) {
          await fetch(`/api/playlists/${playlistId}/import`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ urls: [url.trim()] })
          });
        } else {
          await fetch("/api/tracks", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ playlistId, url })
          });
        }
        trackForm.reset();
        fetchPlaylists();
        fetchDownloads();
      });

      document.getElementById("logout").addEventListener("click", async () => {
        await fetch("/api/auth/logout", { method: "POST" });
        window.location.href = "/login";
      });

      document.getElementById("clear-downloads").addEventListener("click", async () => {
        await fetch("/api/downloads/clear", { method: "POST" });
        fetchDownloads();
      });

      autoVoteToggle.addEventListener("change", async () => {
        await fetch("/api/settings", {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ vote_auto_enabled: autoVoteToggle.checked ? 1 : 0 })
        });
      });

      settingsForm.addEventListener("submit", async (event) => {
        event.preventDefault();
        settingsStatus.textContent = "Saving...";
        await fetch("/api/settings", {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            vote_options: Number(settingsVoteOptions.value || 5),
            vote_duration: Number(settingsVoteDuration.value || 30),
            vote_lead_time: Number(settingsVoteLead.value || 20),
            vote_auto_enabled: autoVoteToggle.checked ? 1 : 0,
            twitch_welcome_message: settingsTwitchWelcome.value,
            twitch_vote_start_message: settingsTwitchVoteStart.value,
            twitch_vote_option_message: settingsTwitchVoteOption.value,
            twitch_vote_end_message: settingsTwitchVoteEnd.value,
            twitch_now_playing_message: settingsTwitchNowPlaying.value,
            twitch_no_active_vote_message: settingsTwitchNoActive.value,
            twitch_vote_closed_message: settingsTwitchVoteClosed.value,
            twitch_invalid_vote_message: settingsTwitchInvalidVote.value,
            twitch_skip_message: settingsTwitchSkip.value,
            twitch_pause_message: settingsTwitchPause.value,
            twitch_resume_message: settingsTwitchResume.value
          })
        });
        settingsStatus.textContent = "Settings saved.";
        setTimeout(() => {
          settingsStatus.textContent = "";
        }, 3000);
      });

      const ws = new WebSocket(`${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws`);
      ws.addEventListener("message", (event) => {
        const message = JSON.parse(event.data);
        if (message.event === "STATE_UPDATE" || message.event === "QUEUE_UPDATE") {
          fetchState();
          return;
        }
        if (message.event === "PLAYLIST_UPDATE") {
          fetchPlaylists();
          return;
        }
        if (message.event === "DOWNLOAD_UPDATE") {
          fetchDownloads();
          fetchPlaylists();
          return;
        }
        if (message.event === "POOL_UPDATE") {
          fetchPool();
          return;
        }
        if (message.event === "SETTINGS_UPDATE") {
          fetchSettings();
          return;
        }
        if (message.event === "VOTE_START") {
          setActiveVote(message.payload);
          return;
        }
        if (message.event === "VOTE_UPDATE") {
          if (activeVote && message.payload.roundId === activeVote.roundId) {
            setActiveVote({ ...activeVote, counts: message.payload.counts });
          } else if (!activeVote) {
            setActiveVote(message.payload);
          }
          return;
        }
        if (message.event === "VOTE_END") {
          if (activeVote && message.payload.roundId === activeVote.roundId) {
            setActiveVote({ ...message.payload, status: "Ended" });
          }
          setTimeout(() => {
            setActiveVote(null);
          }, 5000);
          return;
        }
        if (message.event === "CHAT_MESSAGE") {
          appendChatMessage(message.payload);
        }
      });

      fetchState();
      fetchPlaylists();
      fetchDownloads();
      fetchSettings();
      fetchActiveVote();
      fetchPool();
    </script>
  </body>
</html>
